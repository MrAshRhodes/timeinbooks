"""Quote formatting utilities."""
import re
from typing import Dict, Optional
from dataclasses import dataclass, asdict

from time_patterns import TimeMatch
import config


@dataclass
class Quote:
    """A formatted quote ready for the clock."""
    quote_first: str
    quote_time_case: str
    quote_last: str
    title: str
    author: str
    sfw: str = "yes"

    def to_dict(self) -> Dict:
        """Convert to dictionary."""
        return asdict(self)


def clean_text(text: str) -> str:
    """Clean and normalize text."""
    # Normalize whitespace
    text = re.sub(r'\s+', ' ', text)
    # Remove control characters
    text = re.sub(r'[\x00-\x1f\x7f-\x9f]', '', text)
    # Normalize quotes
    text = text.replace('"', '"').replace('"', '"')
    text = text.replace(''', "'").replace(''', "'")
    return text.strip()


def extract_quote_context(
    text: str,
    match: TimeMatch,
    chars_before: int = None,
    chars_after: int = None
) -> Optional[Quote]:
    """Extract quote context around a time match."""
    if chars_before is None:
        chars_before = config.CONTEXT_CHARS_BEFORE
    if chars_after is None:
        chars_after = config.CONTEXT_CHARS_AFTER

    # Calculate extraction boundaries
    start = max(0, match.start_pos - chars_before)
    end = min(len(text), match.end_pos + chars_after)

    # Extract and find sentence boundaries
    quote_first = text[start:match.start_pos]
    quote_last = text[match.end_pos:end]

    # Try to start at sentence boundary
    sentence_starts = [m.end() for m in re.finditer(r'[.!?]\s+', quote_first)]
    if sentence_starts:
        last_start = sentence_starts[-1]
        if len(quote_first) - last_start < chars_before * 0.7:
            quote_first = quote_first[last_start:]

    # Try to end at sentence boundary
    sentence_ends = list(re.finditer(r'[.!?]', quote_last))
    if sentence_ends:
        first_end = sentence_ends[0].end()
        if first_end > chars_after * 0.3:
            quote_last = quote_last[:first_end]

    # Clean up
    quote_first = clean_text(quote_first)
    quote_last = clean_text(quote_last)
    time_text = clean_text(match.time_text)

    # Validate length
    total_length = len(quote_first) + len(time_text) + len(quote_last)
    if total_length < config.MIN_QUOTE_LENGTH or total_length > config.MAX_QUOTE_LENGTH:
        return None

    return Quote(
        quote_first=quote_first,
        quote_time_case=time_text,
        quote_last=quote_last,
        title="",
        author=""
    )


def format_quotes_js(quotes: Dict[str, list]) -> str:
    """Format quotes dictionary as JavaScript."""
    lines = [
        "// Literary Quote Clock - Quote Database",
        "// Auto-generated by quote-scraper",
        f"// Total quotes: {sum(len(v) for v in quotes.values())}",
        "",
        "const QUOTES = {"
    ]

    for time_key in sorted(quotes.keys()):
        quote_list = quotes[time_key]
        if not quote_list:
            continue

        lines.append(f'  "{time_key}": [')

        for quote in quote_list:
            q = quote if isinstance(quote, dict) else quote.to_dict()
            lines.append("    {")
            lines.append(f'      "quote_first": {_js_string(q["quote_first"])},')
            lines.append(f'      "quote_time_case": {_js_string(q["quote_time_case"])},')
            lines.append(f'      "quote_last": {_js_string(q["quote_last"])},')
            lines.append(f'      "title": {_js_string(q["title"])},')
            lines.append(f'      "author": {_js_string(q["author"])},')
            lines.append(f'      "sfw": "{q.get("sfw", "yes")}"')
            lines.append("    },")

        lines.append("  ],")

    lines.append("};")

    return "\n".join(lines)


def _js_string(s: str) -> str:
    """Escape string for JavaScript."""
    s = s.replace('\\', '\\\\')
    s = s.replace('"', '\\"')
    s = s.replace('\n', '\\n')
    s = s.replace('\r', '\\r')
    s = s.replace('\t', '\\t')
    return f'"{s}"'
